# 中间件
## keepalived 
### 概览 
主要是HA作用，通过vrrp协议，借助vip的漂移来实现故障机器的快速切换
### 问题 
脑裂问题，构建自定义脚本检测kp的状态，如果有问题就重启或者kill
## ngxin
### 概览

反向代理服务器

基于NIO的高并发

zerocopy减少cpu的资源切换消耗

多个后端机器的策略有：轮询、最小链接、权重

ngxin+lua实现用户无感知系统版本升级

### 问题


# 数据库
## 事务（acid）
### acid

 一致性、持久性、隔离性、原子性

### 
## mysql

### 概述
### 事务级别（mysql为了解决多线程下的读写解决方案）

![image](https://user-images.githubusercontent.com/3971073/168755190-c07a34fc-32ef-498e-8988-0f8bb0c3157c.png)

脏读：读取到其他事务未提交的脏数据

不可重复读：在同一个事务中，多次读取的结果不一致

可重复读：在同一个事务中，多次读取的结果一致

幻读：A事务读取数据的时候，B事务插入会导致A事务查询到，所以需要加锁，区间锁

读未提交

读已提交 

可重复读 （会出现幻读 解决方案mvcc，通过两个隐藏的数据版本来实现）

串行 （没有任何问题，但是效率很低）

### 锁类型
行级别锁

表级别锁

读锁（共享锁s）

写锁（排他锁x）

gap锁 （间隙锁）

next-key 锁（间隙锁+行锁，就锁住特定区间内的行锁）

悲观锁 （for update 指定加锁操作）

乐观锁 （mvcc多版本控制）

#### 索引

聚簇索引（数据存储在叶子节点的索引，只有一个，并且是innodb特有的）

非聚簇索引（叶子节点只是存储主键id）

聚合索引

最左前缀匹配

针对聚合索引，多个索引的使用规则，例如abc的聚合索引，sql中的顺序不用担心，会有优化器优化顺序，在具体使用的时候遵循a是全局有序，b是局部有序，依次类推，同时遇到between like < > 会无法走索引 

### 存储引擎

#### 内存

基于内存存储，可以做缓存

#### innodb

行级别锁

支持事务

表行数不存储

聚簇索引

文件分为frm、 idb（表格式文件、数据）

支持外键


#### myisam

表级别锁 

无事务支持

存储表行数

非聚簇索引

文件分为frm、myd、myi（表格式文件、数据、索引）

不支持外键

### 主从复制
####  


### 问题
- where + order by limit 会出现使用错误索引的情况，导致执行变慢 可以使用explain查看执行计划，然后使用指定索引 force index()
- 插入emoji数据的时候需要设置编码为utf8mb4 因为emoji的长度为4个字节，utf8为1-3个字节

# 缓存
## redis
### 概述


#### 高性能
单线程（减少线程切换消耗）

nio（多路复用io模型，提升io效率）

kv数据（时间复杂度1）

内存数据库

#### 数据结构
string
- string 有int raw大字符串 embstr 短字符串
- sds 简单动态字符串
- 惰性删除
- 内存预分配 1M以上一次1M，小于1M就是翻倍

zset
- 128 64转换skiplist

list
- quicklist 不是linkedlist 主要是为性能考虑，quick的基础是ziplist

set
- 512 或者64k转换为skplist

hash
-  512 或者64k转换为skplist

bitmap
- 实现布隆过滤器

geo
- 地图数据

HyperLogLog
- 不精准的去重计数


skplist 跳表存储 和红黑树一样logn的时间复杂度，但是实现简单
跳表就是多层索引，每层索引是下层的部分节点，新增的节点通过投硬币的方式来决定放置的层级
ziplist 少量的数据用 特殊的双向链表，主要是存储连续
hash表的渐进式rehash
非bgsave下进行，负载因子=use/cnt，当>5的时候开始扩容，0.1的时候开始缩容。是每一次操作进行递增操作hash值，-1变成0，开始进行rehash。完成表示为-1


### 存储
rdb 快照
aof 日志，比较大的时候可以命令Bgrewriteaof 来进行压缩文件


### 集群
 sentinel 模式 哨兵模式 监控redis节点状态，做选主操作
 redis cluter 模式，16384个slots 多机器分片处理16384，取mod来确定存储的机器。
 一致性hash，将机器和数据节点hash到一个圈中，然后顺时针确定缓存存在哪个机器，是没有集群模式的一个存储方案，目前是通过
 
### 用途
缓存、分布式缓存
- 缓存删除策略
 allkey lru、过期key lru
 惰性删除 在访问的时候发现过去就删除
 随机删除 定时随机检测，如何过期就删除

分布式锁
- setnx 不存在就插入，来实现分布式锁，但是会有问题导致锁删除失败
- setnx+ expire 但是也会导致expire一直无法延期
- setnx+ expire+ redisson 看门狗实现自动对操作期间的延期，ttl不要设置，这样才可以生效，否则会不生效
- 多机器使用redlock 多个机器获取锁，需要不超时，每个节点的超时是总减去当前节点获取锁的时间，并且节点半数以上才任务获取锁成功

分布式id生成
- 其他方案tddl的 内外步长+内存

### 事务
 watch监听 、multi 执行命令
 lua实现原子操作
### 故障转移
基于raft协议，多数标记节点下线，选择复制主节点较多数据的节点为新的主节点
### 问题
- 大key问题
会导致oom和超时的等问题bigkey命令查看，然后做拆解
- 缓存失效问题
使用随机过期时间防止缓存雪崩

## 
## 
# 大数据
## HBASE
### 概览
hbase通过zk拿到meta表，然后获取root表，获取regionserver信息
 
### 问题
没有二级索引，需要自己构建
## ES
###
## HADOOP
### 概览
map
分片读取数据etl，生成kv数据
调整map的文件读取大小、

shuffle
在map端产出数据放在环形内存中，超过阈值，溢出为本地文件，在生成本地文件的时候根据reduce的个数进行分区排序。reduce端根据自己的分区号通过map的http服务拉取数据到本地，然后进行内存溢出文件合并
reduce


## HIVE
### 概览
基于hdfs的sql执行引擎
## BLINK


# 分布式
## 分布式事务
在数据库分库分表情况下需要处理分布式事务问题，所以需要知道
cap 模型 c一致性 a 可用性 p分区容错性  强一致性
base 模型 ba 基本可用 s 软状态 e 最终一致性 
### xa协议 强一致性

2pc prepare、 commit/rollback 方案 问题是 提交状态crash不知道如何操作

3pc 解决2pc的部分问题，prepare 、precommit 、commit
### 最终一致性
tcc try confirm、cancel
saga




### 
- 消息队列

## 分布式缓存

## 分布式锁

## 分布式调度

# 安全
# 逆向
